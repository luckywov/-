# 游戏规则

玩家选择两个宝石进行位置互换，互换后如果横排或者竖排有三个以上相同的宝石，则消去这几个相同的宝石，如果互换后没有可以消去的宝石，则选中的两个宝石换回原来的位置。

消去后的空格由上面的宝石掉下来补齐，每次消去宝石玩家都能得到一定的分数

**连锁**

玩家消去宝石后，上面的宝石掉下来会补充空格，如果这时游戏池中有满足消除条件的宝石，则继续消除，每次连锁都会加分，直到无法发生连锁为止.

**重排**

玩家已经无法消除任何宝石了，此时将清空游戏池，用新的宝石填充

# 程序思路

## 1地图生成

这里使用列表（动态数组），数组内每个坐标代表一颗宝石。每一条temp列表为一行，一行建立完后，将此条temp列表存入List列表中。

动态数组的优点：可以实时改变数组长度，并且可以在指定位置插入新的元素

宝石的随机生成：利用随机函数，随机填充不同宝石

## 2消除检测

获取图案相同的图像，一定要以一个对象为基准，这样才能直到以谁为中心，以这个中心为核心的横向纵向进行检测，检测到三个以上的对象时，则可以进行消除

从左上至左下，横向遍历，将符合条件的方块存储在临时数组里

从左上至右上，竖向遍历，将符合消除条件的方块存储在临时数组里

遍历之后将符合条件的方块消除

## 3消除算法

在地图遍历结束，并且所有可以消除的宝石都存入了消除列表之后，我们利用遍历消除列表来调用消除函数，在消除宝石并且生成新的宝石后，再次调用遍历函数，这样就可以在新的宝石生成后，将地图上可消除的宝石消除了

 ```伪代码
void 消除函数
{
   消除宝石代码;
}

void 消除列表
 {
   for(遍历循环)
   {
     调用消除函数;
   }
   调用延迟调用函数;
 }
 
 延迟调用函数
 {
    延迟0.5秒;
    调用地图遍历检测;
    调用消除列表函数;
 }

 ```

优先级：5连>L/T形>4连>3连

## 4宝石掉落

在宝石A消除后，存储并传递被消除宝石上方的宝石B数据，在B下方生成一个新的B，并将原有的B消除，循环遍历，最后在最上方生成新的宝石C，即可达成所有宝石掉落的效果

```伪代码
for(遍历)
{
  temGemstone = 获取B的数据;
  改temGemstone的位置;
   生成新的B;
}
new Gemstone = 获取新的宝石C的位置 ;
更改C的位置;
生成新的C;

```

# 5游戏流程图

![QQ截图20220611181500](D:\Afirst\Unity\经典游戏\Eliminate\QQ截图20220611181500.png)