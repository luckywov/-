# 程序思路

## 1、地图生成

地图存储：

我们可以使用二维数组来存储地图信息。

每个元素中用不同的数字来标记不同的对象。

0表示空，1表示墙，2表示角色，3表示箱子，9表示终点（9表示终点是为了方便以后添加其它颜色的箱子）



地图生成：通过遍历地图二维数组，读取每个元素的值，根据数值标记，生成不同的地图对象。由于一维数组在编译地图以及可以更简便地表示角色以及箱子在数内地移动，所以我们也可以使用一维数组来存储地图数组。

这里我们用一维数组来表示

二维数组映射到一维数组地公式为：b[i*n+j] = a[i]\[j]

设数组有m行n列，i，j分别表示数组内地行数与列数（0<i<m,0<j<n)



## 2、角色移动

角色移动：数组为9*9的一维数组，其中左上角为原点，即 map[0]，二维数组中为[0]\[0]



- **角色在数组内表示**

角色目前位置 二维数组：[4]\[4]

​			一维数组：[4*9+4] = map[40]

1. 角色上侧第一个方格:	 [3]\[4]

   ​			   		 [3*9+4] = map[31]

2. 角色下侧第一个方格:	 [5]\[4]

   ​			   		 [5*9+4] = map[49]

3. 角色左侧第一个方格:	 [4]\[3]

   ​			   		 [4*9+3] = map[39]

4. 角色右侧第一个方格:	 [4]\[5]

   ​			   		 [4*9+5] = map[41]

实现如下：

定义一个枚举类型

```C#
public enum Direction{Up=-9,Down=9,Left=-1.Right=1}
public Direction dir;
```



- 角色的移动

由上分析，设定dir控制角色在数组内的移动距离

1. 向上移动：获取到按键“↑”，此时dir = Direction.Up;	     将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，刷新角色
2. 向下移动：获取到按键“↓”，此时dir = Direction.Down;将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，刷新角色
3. 向左移动：获取到按键“←”，此时dir = Direction.Left;  将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，刷新角色
4. 向右移动：获取到按键“→”，此时dir = Direction.Right;将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，刷新角色

- 遇到障碍物时，跳出遍历，返回false



## 3、箱子移动

箱子的移动与角色的移动相同，如下：

- 箱子的移动 设定dir控制角色在数组内的移动距离

1. 向上移动：获取到按键“↑”，此时dir = Direction.Up;	     将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，下二目标移动位置的数组值变为3，刷新角色及箱子
2. 向下移动：获取到按键“↓”，此时dir = Direction.Down;将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，下二目标移动位置的数组值变为3，刷新角色及箱子
3. 向左移动：获取到按键“←”，此时dir = Direction.Left;  将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，下二目标移动位置的数组值变为3，刷新角色及箱子
4. 向右移动：获取到按键“→”，此时dir = Direction.Right;将角色目前位置的数组值变为0，向下一目标移动位置的数组值变为2，下二目标移动位置的数组值变为3，刷新角色及箱子

- 遇到障碍物时，跳出遍历，返回false

## 4、角色及箱子移动逻辑

```伪代码
if(玩家按键"↑")		dir = Direction.Up;
else if(玩家按键"↓") dir = Direction.Down;
else if(玩家按键"←") dir = Direction.Left;
else if(玩家按键"→") dir = Direction.Right;

if(下一位置为空)
{
  temp_map[角色目前位置(i*n+j)] = 0;
  temp_map[角色下一位置(i*n+j+dir)] = 2;
}
if(下一位置为箱子)
{
  temp_map[角色目前位置(i*n+j)] = 0;
  temp_map[角色下一位置(i*n+j+dir)] = 2;
  temp_map[角色下二位置(i*n+j+dir)] = 3;
}
if(下一位置为墙壁)
{
  return false;
}
```

地图刷新：人物或箱子可以移动后，将人物或箱子在数组内对应位置的值设为0，对应移动目标位置的数组的值设为人物或箱子的值，最后刷新人物或箱子即可



逻辑图：

![img](file:///C:\Users\流星画魂\Documents\Tencent Files\1214593142\Image\C2C\ADB564B2F6D2FC42DD73190469B5364A.jpg)



## 5、游戏获胜判定

由程序遍历地图，当地图中没有不与地图重合的箱子时，玩家获胜。注：初始箱子名为Box，当箱子与终点重合时，刷新名为FinalBox的箱子，两种箱子颜色不同

``` 伪代码
if(没有Box)
{
  玩家获胜;
}
```

## 6、游戏流程图

![img](file:///C:\Users\流星画魂\Documents\Tencent Files\1214593142\Image\C2C\D6941D84A5395A668B0AF5F80DE33DF4.jpg)